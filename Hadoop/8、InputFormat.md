# InputFormat

## FileInputFormat切片分析

FileInputFormat是所有使用文件作为数据源的InputFormat实现的基类。一个是用于指出job文件的输入路径，一个是为输出文件生成分片的代码实现。

### FileInputFormat默认切片策略

切片的大小由minSize,gloabSize和blocksize共同作用后确定。FileInputFormat更加适合用于大文件的切割，因为他是按照文件切割，一个小文件也会成为一个块。

```java
ArrayList<FileSplit> splits = new ArrayList<FileSplit>(numSplits);
    NetworkTopology clusterMap = new NetworkTopology();
    // 遍历文件，一个文件一个文件的切
    for (FileStatus file: files) {
      Path path = file.getPath();
      long length = file.getLen();
      if (length != 0) {
        //获得一个文件系统
        FileSystem fs = path.getFileSystem(job);
        BlockLocation[] blkLocations;
        if (file instanceof LocatedFileStatus) {
          blkLocations = ((LocatedFileStatus) file).getBlockLocations();
        } else {
          blkLocations = fs.getFileBlockLocations(file, 0, length);
        }
        // 判断是否可切。压缩文件什么的就不能切。如果不能切的话整个文件作为一个split
        if (isSplitable(fs, path)) {
          long blockSize = file.getBlockSize();
        // computeSplitSize(long goalSize, long minSize,long blockSize) {Math.max(minSize, Math.min(goalSize, blockSize))};，
        // 通过修改minSize和maxSize就可以控制切片的大小。
          long splitSize = computeSplitSize(goalSize, minSize, blockSize);
          long bytesRemaining = length;
        // 当文件剩下的大小小于SPLIT_SLOP时就不切了，SPLIT_SLOP默认为1.1，也就是说如果最后块的大小小于splitSize*1.1就不切了。
          while (((double) bytesRemaining)/splitSize > SPLIT_SLOP) {
            String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations,
                length-bytesRemaining, splitSize, clusterMap);
            splits.add(makeSplit(path, length-bytesRemaining, splitSize,
                splitHosts[0], splitHosts[1]));
            bytesRemaining -= splitSize;
          }

        // 剩下的大于1.1小于1.1的块单独作为一个切片，如果切片最后的是个空片，也要作为一个片。
          if (bytesRemaining != 0) {
            String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations, length
                - bytesRemaining, bytesRemaining, clusterMap);
            splits.add(makeSplit(path, length - bytesRemaining, bytesRemaining,
                splitHosts[0], splitHosts[1]));
          }
        } else {
          String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations,0,length,clusterMap);
          splits.add(makeSplit(path, 0, length, splitHosts[0], splitHosts[1]));
        }
      } else {
        //Create empty hosts array for zero length files
        splits.add(makeSplit(path, 0, length, new String[0]));
      }
    }
    sw.stop();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Total # of splits generated by getSplits: " + splits.size()
          + ", TimeTaken: " + sw.now(TimeUnit.MILLISECONDS));
    }
    return splits.toArray(new FileSplit[splits.size()]);
  }
```

### CombineInputFormat切片分析

