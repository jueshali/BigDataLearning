# InputFormat

- [InputFormat](#inputformat)
  - [FileInputFormat切片分析](#fileinputformat%e5%88%87%e7%89%87%e5%88%86%e6%9e%90)
    - [FileInputFormat默认切片策略](#fileinputformat%e9%bb%98%e8%ae%a4%e5%88%87%e7%89%87%e7%ad%96%e7%95%a5)
    - [TextInputFormat](#textinputformat)
    - [KeyValueInputFormat](#keyvalueinputformat)
    - [NLineInputFormat](#nlineinputformat)
    - [CombineTextInputFormat](#combinetextinputformat)
    - [自定义类继承FileInputFormat](#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e7%bb%a7%e6%89%bffileinputformat)

## FileInputFormat切片分析

FileInputFormat是所有使用文件作为数据源的InputFormat实现的基类。一个是用于指出job文件的输入路径，一个是为输出文件生成分片的代码实现。

### FileInputFormat默认切片策略

切片的大小由minSize,gloabSize和blocksize共同作用后确定。FileInputFormat更加适合用于大文件的切割，因为他是按照文件切割，一个小文件也会成为一个块。

```java
ArrayList<FileSplit> splits = new ArrayList<FileSplit>(numSplits);
    NetworkTopology clusterMap = new NetworkTopology();
    // 遍历文件，一个文件一个文件的切
    for (FileStatus file: files) {
      Path path = file.getPath();
      long length = file.getLen();
      if (length != 0) {
        //获得一个文件系统
        FileSystem fs = path.getFileSystem(job);
        BlockLocation[] blkLocations;
        if (file instanceof LocatedFileStatus) {
          blkLocations = ((LocatedFileStatus) file).getBlockLocations();
        } else {
          blkLocations = fs.getFileBlockLocations(file, 0, length);
        }
        // 判断是否可切。压缩文件什么的就不能切。如果不能切的话整个文件作为一个split
        if (isSplitable(fs, path)) {
          long blockSize = file.getBlockSize();
        // computeSplitSize(long goalSize, long minSize,long blockSize) {Math.max(minSize, Math.min(goalSize, blockSize))};，
        // 通过修改minSize和maxSize就可以控制切片的大小。
          long splitSize = computeSplitSize(goalSize, minSize, blockSize);
          long bytesRemaining = length;
        // 当文件剩下的大小小于SPLIT_SLOP时就不切了，SPLIT_SLOP默认为1.1，也就是说如果最后块的大小小于splitSize*1.1就不切了。
          while (((double) bytesRemaining)/splitSize > SPLIT_SLOP) {
            String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations,
                length-bytesRemaining, splitSize, clusterMap);
            splits.add(makeSplit(path, length-bytesRemaining, splitSize,
                splitHosts[0], splitHosts[1]));
            bytesRemaining -= splitSize;
          }

        // 剩下的大于1.1小于1.1的块单独作为一个切片，如果切片最后的是个空片，也要作为一个片。
          if (bytesRemaining != 0) {
            String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations, length
                - bytesRemaining, bytesRemaining, clusterMap);
            splits.add(makeSplit(path, length - bytesRemaining, bytesRemaining,
                splitHosts[0], splitHosts[1]));
          }
        } else {
          String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations,0,length,clusterMap);
          splits.add(makeSplit(path, 0, length, splitHosts[0], splitHosts[1]));
        }
      } else {
        //Create empty hosts array for zero length files
        splits.add(makeSplit(path, 0, length, new String[0]));
      }
    }
    sw.stop();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Total # of splits generated by getSplits: " + splits.size()
          + ", TimeTaken: " + sw.now(TimeUnit.MILLISECONDS));
    }
    return splits.toArray(new FileSplit[splits.size()]);
  }
```

### TextInputFormat

切片：采用父类切片策略。
RecordReader：采用LineRecorder，读取一行作为一个key-value.key是改行的偏移量，Text是改行的内容。

### KeyValueInputFormat

切片：默认的切片策略！
RecordReader:  KeyValueLineRecordReader ： 读取一行，使用分隔符分割每行，封装key-value
Text Key: 分隔符前内容
Text value: 分隔符后的内容

### NLineInputFormat

切片： 以文件为单位，切分文件的mapreduce.input.lineinputformat.linespermap行(如果没有指定，默认为1)作为一个切片！
RecordReader:   LineRecordReader ： 读取一行作为一个key-value
LongWritable key: 每行的偏移量
Text value:  每行的内容
适合宽行数据的处理！(一次切几行增加并行度)

### CombineTextInputFormat

CombineTextInputFormat可以将多个小文件合并到一个切片中处理！主要是为了解决小文件过多的问题，决定哪些块放在一起时，CombineTextInputFormat也会考虑节点和机架的因素。
设置一个参数，每片的大小mapreduce.input.fileinputformat.split.maxsiz（maxSize）

切片策略：

（a）判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片。\
（b）如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。\

RecordReader:  LineRecordReader ： 读取一行作为一个key-value\
LongWritable：key: 每行的偏移量\
Text value:  每行的内容

### 自定义类继承FileInputFormat
