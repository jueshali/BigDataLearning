# Hive 优化

## Fetch抓取 

Fetch抓取是指，Hive中对某些情况的查询可以不必使用MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive可以简单地读取employee对应的存储目录下的文件，然后输出查询结果到控制台。在hive-default.xml.template文件中hive.fetch.task.conversion默认是more，该属性修改为more以后，在全局查找、字段查找、limit查找等都不走mapreduce。

## 本地模式

在yarn上申请资源用的时间大于实际计算的时间时可以采用本地模式，通过本地模式，HIVE可以通过本地模式在本机上处理所有的任务，适用与小数据集的处理。set hive.exec.mode.local.auto=true

## 表的优化

### 大表Join小表

将key相对分散，并且数据量小的表放在join的左边，这样可以有效减少内存溢出错误发生的几率；目前Hive对此进行了优化,小表在左边还是右边已经没有明显的区别.

### 大表Join大表

### MapJoin

### Group By

### 去重统计

### 笛卡尔积

### 行列过滤

### 动态分区

### 分桶

### 分区

## 数据倾斜

Map数不能太多，也不能太少，太多一个map任务的启动需要向yarn申请资源走一遍流程，浪费大量时间。也不能太少，会让一个Map任务处理的时间大大增加.

## 并行执行

Hive会将一次查询转换为多个阶段，默认情况下Hive一次只会执行一个阶段，不过某个特定的job可能包含多个阶段，这些阶段并不是相互依赖的，也就是说可以并行运算通过设置`hive.exec.parallel = true`。值得注意的是在并行阶段增多的情况下，集群的利用率会增加。

## 严格模式

通过设置`hive.mapred.mode=strict`可以设置为严格模式。严格模式可以防止用户执行可能产生意想不到的不好的影响的查询。

1. 对于分区表，除非where语句中含有分区字段过滤条件来限制数据的范围，否则不能执行。
2. 对于使用了Order By的语句，必须使用Limit语句，因为执行Order by是一个全局排序，只能有一个Reduce阶段，所以如果不适用Limit的话，这一个Reduce的执行时间会过长。
3. 	限制笛卡尔积的查询。对关系型数据库非常了解的用户可能期望在执行JOIN查询的时候不使用ON语句而是使用where语句，这样关系数据库的执行优化器就可以高效地将WHERE语句转化成那个ON语句。

## JVM重用

JVM重用是Hadoop调优参数的内容，其对Hive的性能具有非常大的影响，特别是对于很难避免小文件的场景或task特别多的场景，这类场景大多数执行时间都很短。
Hadoop的默认配置通常是使用派生JVM来执行map和Reduce任务的。这时JVM的启动过程可能会造成相当大的开销，尤其是执行的job包含有成百上千task任务的情况。JVM重用可以使得JVM实例在同一个job中重新使用N次。

## 推测执行

给可能拖后腿的任务建立一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。

## 执行计划

查看HQL的执行计划.
EXPLAIN [EXTENDED | DEPENDENCY | AUTHORIZATION] query 可以看stage的个数，找中有没有可能通过优化减少它。